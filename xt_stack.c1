/*************************************************
 * Copyright:   XT Tech. Co., Ltd.
 * File name:   xt_stack.c
 * Author:      xt
 * Version:     1.0.0
 * Date:        2022.06.04
 * Code:        UTF-8(No BOM)
 * Description: 双向链表栈数据结构实现
*************************************************/

#include "xt_stack.h"

long _InterlockedCompareExchange(
   long volatile * Destination,
   long Exchange,
   long Comparand
);

执行值与 Comparand 值的原子比较 Destination 。 如果 Destination 值等于 Comparand 值，Exchange 值将存储在由 Destination 指定的地址。 否则，不执行任何操作。


#ifdef WIN32
#include <Windows.h>
// 如果ptr指向的值等于old则,将ptr=newval
#define CAS(ptr,oldval,newval)  (oldval == InterlockedCompareExchange((long*)ptr, newval, oldval))
#else
#define CAS(ptr,oldval,newval)  __sync_bool_compare_and_swap(ptr, oldval, newval)
#endif


/**
 *\brief            栈初始化
 *\param[int|out]   p_stack stack 栈
 *\return           0-成功
 */
int stack_init(p_stack stack)
{
    if (NULL == stack)
    {
        printf("%s|input param is null", __FUNCTION__);
        return -1;
    }

    stack->head = NULL;
    stack->count = 0;
    return 0;
}

/**
 *\brief     节点入栈
 *\param[in] p_stack        stack   栈
 *\param[in] p_stack_node   node    栈节点
 *\return    0-成功
 */
int stack_push(p_stack stack, p_stack_node node)
{
    if (NULL == stack || NULL == node)
    {
        printf("%s|input param is null", __FUNCTION__);
        return -1;
    }

    /*
    p_stack_node top = NULL;

    do
    {
        top = stack->top;

        node->next = top;

    } while (!CAS(&(stack->top), top, node));
    */

    node->next = stack->top;
    stack->top = node;
    stack->count++;
    return 0;
}

/**
 *\brief     节点出栈
 *\param[in] p_stack stack 栈
 *\return    栈节点
 */
p_node stack_pop(p_stack stack)
{
    if (NULL == stack)
    {
        ERR("input param is null");
        return NULL;
    }

    /*
    do
    {
        top = stack->top;

        if (NULL == top)
        {
            pthread_mutex_unlock(&stack->mutex);
            return NULL;
        }

    } while (!CAS(&(stack->top), top, top->next));
    */

    p_node top = stack->top;

    if (NULL == top)
    {
        return NULL;
    }

    stack->top = top->next;
    stack->count--;
    return top;
}
